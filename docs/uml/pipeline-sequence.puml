@startuml
title BookvoicePipeline.run - Sequence

actor User
participant "bookvoice.cli\nbuild_command" as CLI
participant "BookvoicePipeline" as PIPE
participant "ArtifactStore" as STORE
participant "PdfTextExtractor" as EXTRACT
participant "TextCleaner" as CLEAN
participant "PdfOutlineChapterExtractor" as OUTLINE
participant "ChapterSplitter" as SPLIT
participant "ChapterStructureNormalizer" as NORMALIZE
participant "TextBudgetSegmentPlanner" as PLAN
participant "SentenceBoundaryRepairer" as REPAIR
participant "OpenAITranslator" as TRANSLATE
participant "AudioRewriter" as REWRITE
participant "OpenAITTSSynthesizer" as TTS
participant "AudioPostProcessor" as POST
participant "AudioMerger" as MERGE
participant "AudioPackager" as PACKAGE

User -> CLI: bookvoice build input.pdf --out out/
CLI -> PIPE: run(config)

PIPE -> PIPE: _prepare_run(config)
PIPE -> STORE: ArtifactStore(output_dir/run-<hash-prefix>)

PIPE -> EXTRACT: extract(input_pdf)
EXTRACT --> PIPE: raw_text
PIPE -> STORE: save_text("text/raw.txt", raw_text)

PIPE -> CLEAN: clean_with_report(raw_text)
CLEAN --> PIPE: clean_text + clean_metadata
PIPE -> STORE: save_text("text/clean.txt", clean_text)

PIPE -> OUTLINE: extract(input_pdf)
OUTLINE --> PIPE: outline chapters or fallback status
alt outline chapters available
  PIPE --> PIPE: chapter_source = "pdf_outline"
else outline unavailable
  PIPE -> SPLIT: split(clean_text)
  SPLIT --> PIPE: chapters[]
  PIPE --> PIPE: chapter_source = "text_heuristic"
end
PIPE -> OUTLINE: extract_structure(input_pdf)
OUTLINE --> PIPE: structure units?
alt no usable outline structure
  PIPE -> NORMALIZE: from_chapters(chapters)
  NORMALIZE --> PIPE: normalized_structure[]
end
PIPE -> STORE: save_json("text/chapters.json", ...)

PIPE -> PLAN: plan(selected_structure_units, budget_chars)
PLAN --> PIPE: segment_plan
PIPE -> PLAN: to_chunks(segment_plan)
PLAN --> PIPE: chunks[]
PIPE -> REPAIR: repair(chunks, target_size)
REPAIR --> PIPE: repaired_chunks[] + metadata
PIPE -> STORE: save_json("text/chunks.json", ...)

loop each chunk
  PIPE -> TRANSLATE: translate(chunk, language)
  TRANSLATE --> PIPE: TranslationResult
end
PIPE -> STORE: save_json("text/translations.json", ...)

loop each translation
  PIPE -> REWRITE: rewrite(translation)
  REWRITE --> PIPE: RewriteResult
end
PIPE -> STORE: save_json("text/rewrites.json", ...)

loop each rewrite
  PIPE -> TTS: synthesize(rewrite, voice)
  TTS --> PIPE: AudioPart
end
PIPE -> STORE: save_json("audio/parts.json", ...)

loop each audio part
  PIPE -> POST: normalize(path)
  POST --> PIPE: normalized_path
  PIPE -> POST: trim_silence(normalized_path)
  POST --> PIPE: trimmed_path
end

PIPE -> MERGE: merge(audio_parts, output_path)
MERGE --> PIPE: merged_audio_path

PIPE -> PACKAGE: package(audio_parts, merged_audio_path, options)
PACKAGE --> PIPE: packaged_outputs[]
PIPE -> STORE: save_json("audio/packaged.json", ...)

PIPE -> STORE: save_json("run_manifest.json", manifest)
PIPE --> CLI: RunManifest
CLI --> User: run_id + merged_audio + manifest_path

@enduml
